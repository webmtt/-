1、let 和 const

    1.块级作用域；2.不存在变量提升；3.不允许重复声明；4.暂时性死区（在代码块内，使用let或const声明变量之前，该变量都是不可用的）；5.声明的全局变量，不属于顶层对象的属性（globalThis对象 [ ES2020 ]）
   const，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

2、变量的解构赋值

  按照一定模式，从数组和对象中提取值，对变量进行赋值
    用途：1.交换变量的值；2.从函数返回多个值；3.函数参数的定义；4.提取 JSON 数据；5.函数参数的默认值；6.遍历 Map 结构；7.输入模块的指定方法

3、字符串

  1.字符的unicode表示法（将码点放入大括号）；2.字符串的遍历器接口（可使用for…of循环遍历）；3.可直接输入 U+2028（行分隔符） 和 U+2029（段分隔符）；4.JSON.stringify()返回转义字符串（若返回不合法的UTF-8字符）；5.模版字符串（限制：无法嵌入其他语言；解决：若遇到不合法字符串转义，就反回undefined）；6.实例：模版编译；6.标签模版（tag`Hello ${ a + b } world ${ a * b}`;’标签’指函数，紧跟在后面的模版字符串就是它的参数；用途：1⃣️过滤HTML字符串，防止用户输入恶意内容；2⃣️多语言转换（国际化处理））；
   1.String.fromCodePoint()；// 从 Unicode 码点返回对应字符，可以识别大于0xFFFF的字符
   2.String.raw()； // 返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串
   3.codePointAt()；//正确处理 4 个字节储存的字符，返回一个字符的码点
   4.normalize()； //将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化
   5.includes()；//返回布尔值，表示是否找到了参数字符串
   6.startsWith()；//返回布尔值，表示参数字符串是否在原字符串的头部
   7.endsWith()；//返回布尔值，表示参数字符串是否在原字符串的尾部
   8.repeat(); //返回一个新字符串，表示将原字符串重复n次
   9.padStart(); //字符串头部补全长度
   10.padEnd(); //字符串尾部补全长度
   11.trimStart(); //消除字符串头部的空格
   12.trimEnd(); //消除字符串尾部的空格
   13.matchAll(); //返回一个正则表达式在当前字符串的所有匹配
   14.replaceAll(); //一次性替换所有匹配

4、正则的扩展

   1.RegExp构造函数；
   2.字符串的正则方法（match()、replace()、search()、split()）；
   3.u修饰符（含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符）{(1) 点字符 (2) Unicode字符表示法 (3) 量词 (4) 预定义模式 (5) i 修饰符 (6) 转义}；
   4.RegExp.prototype.unicode 属性（表示是否设置了u修饰符）；
   5.y修饰符（“粘连”（sticky）修饰符，与g修饰符类似）；
   6.RegExp.prototype.sticky 属性（是否设置了y修饰符）；
   7.RegExp.prototype.flags 属性（返回正则表达式的修饰符）；
   8.s 修饰符：dotAll 模式（即点（dot）代表一切字符）；
   9.后行断言（x只有在y后面才匹配，必须写成/(?<=y)x/）；
   10.Unicode属性类（\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符）；
   11.具名组匹配（允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用<解构赋值和替换、引用>）；
   12.正则匹配索引（为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置）；
   13.String.prototype.matchAll()（可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组；{遍历器转为数组:1.[...string.matchAll(regex)];2.Array.from(string.matchAll(regex))}）

5、数值的扩展

   1.二进制和八进制表示法（分别用前缀0b（或0B）和0o（或0O）表示）；
   2.Number.isFinite(), Number.isNaN()；
   3.Number.parseInt(), Number.parseFloat()；
   4.Number.isInteger();（用来判断一个数值是否为整数）；
   5.Number.EPSILON(一个极小的常量,表示 1 与大于 1 的最小浮点数之间的差)；
   6.安全整数和 Number.isSafeInteger()；
   7.Math 对象的扩展（1.Math.trunc();用于去除一个数的小数部分，返回整数部分；2.Math.sign();用来判断一个数到底是正数、负数、还是零；3.Math.cbrt();用于计算一个数的立方根；4.Math.clz32();将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0；5.Math.imul();返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数；6.Math.fround();返回一个数的32位单精度浮点数形式；7.Math.hypot();返回所有参数的平方和的平方根；8.Math.expm1();返回 ex - 1，即Math.exp(x) - 1；9.Math.log1p();返回1 + x的自然对数，即Math.log(1 + x)；10.Math.log10()；11.Math.log2()；12.Math.sinh(x);返回x的双曲正弦（hyperbolic sine）；13.Math.cosh(x)；14.Math.tanh(x)；15.Math.asinh(x)；16.Math.acosh(x)；17.Math.atanh(x)）；
   8.指数运算符（**）；
   9.BigInt 数据类型（1.简介：（大整数），只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示；2.BigInt 对象；3.转换规则；4.数学运算）

6、函数的扩展

   1.函数参数的默认值
        1.允许为函数的参数设置默认值，即直接写在参数定义的后面
       2.与解构赋值默认值结合使用
       3.参数默认值的位置（通常情况下是函数的尾参数）
     4.函数的 length 属性（返回没有指定默认值的参数个数）
       5.作用域（一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失）
      6.应用（利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误）
   2. rest 参数（形式为...变量名，用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中）
   3.严格模式（只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错）
   4. name 属性（返回该函数的函数名）
   5.箭头函数
       使用注意点：
      （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
      （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
      （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
      （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
      不适用场合：1.定义对象的方法，且该方法内部包括this；2.需要动态this的时候，也不应使用箭头函数
      嵌套的箭头函数
   6.尾调用优化（1.指某个函数的最后一步是调用另一个函数；2.尾调用优化；3.尾递归；4.递归函数的改写；5.严格模式；6.尾递归优化的实现）
   7.函数参数的尾逗号
   8.Function.prototype.toString()；返回函数代码本身一模一样的原始代码
   9.catch 命令的参数省略
   
7.数组的扩展

   1.扩展运算符
      1.含义：扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列
      2.替代函数的 apply 方法
      3.扩展运算符的应用：（1）复制数组；（2）合并数组；（3）与解构赋值结合；（4）字符串；（5）实现了 Iterator 接口的对象；（6）Map 和 Set 结构，Generator 函数
   2.Array.from()；用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）；（应用：1.可以将各种值转为真正的数组，并且还提供map功能；2.将字符串转为数组，然后返回字符串的长度）
   3.Array.of()；用于将一组值，转换为数组
   4.数组实例的 copyWithin()；在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组
   5.数组实例的 find() 和 findIndex()；用于找出第一个符合条件的数组成员
   6.数组实例的 fill()；使用给定值，填充一个数组
   7.数组实例的 entries()，keys() 和 values()；对键名、键值、键值对的遍历
   8.数组实例的 includes()；返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似
   9.数组实例的 flat()，flatMap()；将嵌套的数组“拉平”；flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法
  10.数组的空位：ES6 则是明确将空位转为undefined
  11.Array.prototype.sort() 的排序稳定性：指的是排序关键字相同的项目，排序前后的顺序不变

8.对象的扩展

  1.属性的简洁表示法（ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法）
 2.属性名表达式（1. 直接用标识符作为属性名；2.用表达式作为属性名，这时要将表达式放在方括号之内）
  3.方法的 name 属性（函数的name属性，返回函数名）
  4.属性的可枚举性和遍历（描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性）
  5.super 关键字（指向当前对象的原型对象）
  6.对象的扩展运算符（1.解构赋值：对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面；2.扩展运算符：对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中）
  7.链判断运算符 ?. （1.短路机制；2.delete 运算符；3.括号的影响；4.报错场合；5.右侧不得为十进制数值）
  8.Null 判断运算符??（它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值）

9.对象的新增方法

  1.Object.is()；（用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致，除了+0、-0与NaN）
  2.Object.assign()；（用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）；）
      注意点：（1）浅拷贝；（2）同名属性的替换；（3）数组的处理；（4）取值函数的处理；
      常见用途：（1）为对象添加属性；（2）为对象添加方法；（3）克隆对象；（4）合并多个对象；（5）为属性指定默认值
  3.Object.getOwnPropertyDescriptors()；（返回指定对象所有自身属性（非继承属性）的描述对象；主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题；另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝）
  4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()
      __proto__属性：用来读取或设置当前对象的原型对象（prototype）
      Object.setPrototypeOf()：用来设置一个对象的原型对象（prototype），返回参数对象本身
      Object.getPrototypeOf()：用于读取一个对象的原型对象
  5.Object.keys()，Object.values()，Object.entries()；（分别返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名、键值、键值对数组）
  6.Object.fromEntries()；是Object.entries()的逆操作，用于将一个键值对数组转为对象；（可配合URLSearchParams对象，将查询字符串转为对象）

12.Symbol

  1.概述（一种新的原始数据类型Symbol，表示独一无二的值）
  2.Symbol.prototype.description（返回 Symbol 的描述）
  3.作为属性名的 Symbol（用于对象的属性名，就能保证不会出现同名的属性）
  4.实例：消除魔术字符串（在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替）
  5.属性名的遍历（该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，可用Object.getOwnPropertySymbols()方法）
  6.Symbol.for()；（可重新使用同一个 Symbol 值，并将其注册到全局，可以用在不同的 iframe 或 service worker 中取到同一个值）、Symbol.keyFor()；（返回一个已登记的 Symbol 类型值的key）
  7.实例：模块的 Singleton 模式（调用一个类，任何时候返回的都是同一个实例）
  8.内置的 Symbol 值
      1.Symbol.hasInstance （对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法）
      2.Symbol.isConcatSpreadable （等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开）
    3.Symbol.species （指向一个构造函数。创建衍生对象时，会使用该属性）
    4.Symbol.match（指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值）
     5.Symbol.replace（指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值）
     6.Symbol.search（指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值）
     7.Symbol.split （指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值）
     8.Symbol.iterator （指向该对象的默认遍历器方法）
     9.Symbol.toPrimitive（指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值）
     10.Symbol.toStringTag（指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型）
     11.Symbol.unscopables（指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除）

13.Set 和 Map 数据结构

  1.Set
      1.基本用法：类似于数组，但是成员的值都是唯一的，没有重复的值
      2.Set 实例的属性和方法（Set.prototype.constructor、Set.prototype.size、Set.prototype.add(value)、Set.prototype.delete(value)、Set.prototype.has(value)、Set.prototype.clear()）
      3.遍历操作（Set.prototype.keys()、Set.prototype.values()、Set.prototype.entries()、Set.prototype.forEach()、扩展运算符（...））
  2.WeakSet（与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先，WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 不能遍历，是因为成员都是弱引用，不会引发内存泄漏）
  3.Map（类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。同set，无add()，变为get()与set()）
  4.Weakap（与Map结构类似，也是用于生成键值对的集合；区别：1.WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名；2.WeakMap的键名所指向的对象，不计入垃圾回收机制）

14.Proxy

  1.概述（Proxy 用于修改某些操作的默认行为，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写）
  2.Proxy 实例的方法
      	get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
		set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
		has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
		deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
		ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
		getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
		defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
		preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
		getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
		isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
		setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
		apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
		construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
  3.Proxy.revocable()；返回一个可取消的 Proxy 实例（Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问）
  4.this 问题（虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理）
  5.实例：Web 服务的客户端（Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。Proxy 也可以用来实现数据库的 ORM 层）

















  



























      







     

