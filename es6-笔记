1、let 和 const

    1.块级作用域；2.不存在变量提升；3.不允许重复声明；4.暂时性死区（在代码块内，使用let或const声明变量之前，该变量都是不可用的）；5.声明的全局变量，不属于顶层对象的属性（globalThis对象 [ ES2020 ]）
   const，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

2、变量的解构赋值

  按照一定模式，从数组和对象中提取值，对变量进行赋值
    用途：1.交换变量的值；2.从函数返回多个值；3.函数参数的定义；4.提取 JSON 数据；5.函数参数的默认值；6.遍历 Map 结构；7.输入模块的指定方法

3、字符串

  1.字符的unicode表示法（将码点放入大括号）；2.字符串的遍历器接口（可使用for…of循环遍历）；3.可直接输入 U+2028（行分隔符） 和 U+2029（段分隔符）；4.JSON.stringify()返回转义字符串（若返回不合法的UTF-8字符）；5.模版字符串（限制：无法嵌入其他语言；解决：若遇到不合法字符串转义，就反回undefined）；6.实例：模版编译；6.标签模版（tag`Hello ${ a + b } world ${ a * b}`;’标签’指函数，紧跟在后面的模版字符串就是它的参数；用途：1⃣️过滤HTML字符串，防止用户输入恶意内容；2⃣️多语言转换（国际化处理））；
   1.String.fromCodePoint()；// 从 Unicode 码点返回对应字符，可以识别大于0xFFFF的字符
   2.String.raw()； // 返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串
   3.codePointAt()；//正确处理 4 个字节储存的字符，返回一个字符的码点
   4.normalize()； //将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化
   5.includes()；//返回布尔值，表示是否找到了参数字符串
   6.startsWith()；//返回布尔值，表示参数字符串是否在原字符串的头部
   7.endsWith()；//返回布尔值，表示参数字符串是否在原字符串的尾部
   8.repeat(); //返回一个新字符串，表示将原字符串重复n次
   9.padStart(); //字符串头部补全长度
   10.padEnd(); //字符串尾部补全长度
   11.trimStart(); //消除字符串头部的空格
   12.trimEnd(); //消除字符串尾部的空格
   13.matchAll(); //返回一个正则表达式在当前字符串的所有匹配
   14.replaceAll(); //一次性替换所有匹配

4、正则的扩展

   1.RegExp构造函数；
   2.字符串的正则方法（match()、replace()、search()、split()）；
   3.u修饰符（含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符）{(1) 点字符 (2) Unicode字符表示法 (3) 量词 (4) 预定义模式 (5) i 修饰符 (6) 转义}；
   4.RegExp.prototype.unicode 属性（表示是否设置了u修饰符）；
   5.y修饰符（“粘连”（sticky）修饰符，与g修饰符类似）；
   6.RegExp.prototype.sticky 属性（是否设置了y修饰符）；
   7.RegExp.prototype.flags 属性（返回正则表达式的修饰符）；
   8.s 修饰符：dotAll 模式（即点（dot）代表一切字符）；
   9.后行断言（x只有在y后面才匹配，必须写成/(?<=y)x/）；
   10.Unicode属性类（\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符）；
   11.具名组匹配（允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用<解构赋值和替换、引用>）；
   12.正则匹配索引（为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置）；
   13.String.prototype.matchAll()（可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组；{遍历器转为数组:1.[...string.matchAll(regex)];2.Array.from(string.matchAll(regex))}）

5、数值的扩展

   1.二进制和八进制表示法（分别用前缀0b（或0B）和0o（或0O）表示）；
   2.Number.isFinite(), Number.isNaN()；
   3.Number.parseInt(), Number.parseFloat()；
   4.Number.isInteger();（用来判断一个数值是否为整数）；
   5.Number.EPSILON(一个极小的常量,表示 1 与大于 1 的最小浮点数之间的差)；
   6.安全整数和 Number.isSafeInteger()；
   7.Math 对象的扩展（1.Math.trunc();用于去除一个数的小数部分，返回整数部分；2.Math.sign();用来判断一个数到底是正数、负数、还是零；3.Math.cbrt();用于计算一个数的立方根；4.Math.clz32();将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0；5.Math.imul();返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数；6.Math.fround();返回一个数的32位单精度浮点数形式；7.Math.hypot();返回所有参数的平方和的平方根；8.Math.expm1();返回 ex - 1，即Math.exp(x) - 1；9.Math.log1p();返回1 + x的自然对数，即Math.log(1 + x)；10.Math.log10()；11.Math.log2()；12.Math.sinh(x);返回x的双曲正弦（hyperbolic sine）；13.Math.cosh(x)；14.Math.tanh(x)；15.Math.asinh(x)；16.Math.acosh(x)；17.Math.atanh(x)）；
   8.指数运算符（**）；
   9.BigInt 数据类型（1.简介：（大整数），只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示；2.BigInt 对象；3.转换规则；4.数学运算）

6、函数的扩展

   1.函数参数的默认值
        1.允许为函数的参数设置默认值，即直接写在参数定义的后面
       2.与解构赋值默认值结合使用
       3.参数默认值的位置（通常情况下是函数的尾参数）
     4.函数的 length 属性（返回没有指定默认值的参数个数）
       5.作用域（一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失）
      6.应用（利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误）
   2. rest 参数（形式为...变量名，用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中）
   3.严格模式（只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错）
   4. name 属性（返回该函数的函数名）
   5.箭头函数
       使用注意点：
      （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
      （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
      （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
      （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
      不适用场合：1.定义对象的方法，且该方法内部包括this；2.需要动态this的时候，也不应使用箭头函数
      嵌套的箭头函数
   6.尾调用优化（1.指某个函数的最后一步是调用另一个函数；2.尾调用优化；3.尾递归；4.递归函数的改写；5.严格模式；6.尾递归优化的实现）
   7.函数参数的尾逗号
   8.Function.prototype.toString()；返回函数代码本身一模一样的原始代码
   9.catch 命令的参数省略
   
7.数组的扩展

   1.扩展运算符
      1.含义：扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列
      2.替代函数的 apply 方法
      3.扩展运算符的应用：（1）复制数组；（2）合并数组；（3）与解构赋值结合；（4）字符串；（5）实现了 Iterator 接口的对象；（6）Map 和 Set 结构，Generator 函数
   2.Array.from()；用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）；（应用：1.可以将各种值转为真正的数组，并且还提供map功能；2.将字符串转为数组，然后返回字符串的长度）
   3.Array.of()；用于将一组值，转换为数组
   4.数组实例的 copyWithin()；在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组
   5.数组实例的 find() 和 findIndex()；用于找出第一个符合条件的数组成员
   6.数组实例的 fill()；使用给定值，填充一个数组
   7.数组实例的 entries()，keys() 和 values()；对键名、键值、键值对的遍历
   8.数组实例的 includes()；返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似
   9.数组实例的 flat()，flatMap()；将嵌套的数组“拉平”；flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法
  10.数组的空位：ES6 则是明确将空位转为undefined
  11.Array.prototype.sort() 的排序稳定性：指的是排序关键字相同的项目，排序前后的顺序不变

8.对象的扩展

  1.属性的简洁表示法（ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法）
 2.属性名表达式（1. 直接用标识符作为属性名；2.用表达式作为属性名，这时要将表达式放在方括号之内）
  3.方法的 name 属性（函数的name属性，返回函数名）
  4.属性的可枚举性和遍历（描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性）
  5.super 关键字（指向当前对象的原型对象）
  6.对象的扩展运算符（1.解构赋值：对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面；2.扩展运算符：对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中）
  7.链判断运算符 ?. （1.短路机制；2.delete 运算符；3.括号的影响；4.报错场合；5.右侧不得为十进制数值）
  8.Null 判断运算符??（它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值）

9.对象的新增方法

  1.Object.is()；（用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致，除了+0、-0与NaN）
  2.Object.assign()；（用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）；）
      注意点：（1）浅拷贝；（2）同名属性的替换；（3）数组的处理；（4）取值函数的处理；
      常见用途：（1）为对象添加属性；（2）为对象添加方法；（3）克隆对象；（4）合并多个对象；（5）为属性指定默认值
  3.Object.getOwnPropertyDescriptors()；（返回指定对象所有自身属性（非继承属性）的描述对象；主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题；另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝）
  4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()
      __proto__属性：用来读取或设置当前对象的原型对象（prototype）
      Object.setPrototypeOf()：用来设置一个对象的原型对象（prototype），返回参数对象本身
      Object.getPrototypeOf()：用于读取一个对象的原型对象
  5.Object.keys()，Object.values()，Object.entries()；（分别返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名、键值、键值对数组）
  6.Object.fromEntries()；是Object.entries()的逆操作，用于将一个键值对数组转为对象；（可配合URLSearchParams对象，将查询字符串转为对象）

10.Symbol

  1.概述（一种新的原始数据类型Symbol，表示独一无二的值）
  2.Symbol.prototype.description（返回 Symbol 的描述）
  3.作为属性名的 Symbol（用于对象的属性名，就能保证不会出现同名的属性）
  4.实例：消除魔术字符串（在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替）
  5.属性名的遍历（该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，可用Object.getOwnPropertySymbols()方法）
  6.Symbol.for()；（可重新使用同一个 Symbol 值，并将其注册到全局，可以用在不同的 iframe 或 service worker 中取到同一个值）、Symbol.keyFor()；（返回一个已登记的 Symbol 类型值的key）
  7.实例：模块的 Singleton 模式（调用一个类，任何时候返回的都是同一个实例）
  8.内置的 Symbol 值
      1.Symbol.hasInstance （对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法）
      2.Symbol.isConcatSpreadable （等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开）
    3.Symbol.species （指向一个构造函数。创建衍生对象时，会使用该属性）
    4.Symbol.match（指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值）
     5.Symbol.replace（指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值）
     6.Symbol.search（指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值）
     7.Symbol.split （指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值）
     8.Symbol.iterator （指向该对象的默认遍历器方法）
     9.Symbol.toPrimitive（指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值）
     10.Symbol.toStringTag（指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型）
     11.Symbol.unscopables（指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除）

11.Set 和 Map 数据结构

  1.Set
      1.基本用法：类似于数组，但是成员的值都是唯一的，没有重复的值
      2.Set 实例的属性和方法（Set.prototype.constructor、Set.prototype.size、Set.prototype.add(value)、Set.prototype.delete(value)、Set.prototype.has(value)、Set.prototype.clear()）
      3.遍历操作（Set.prototype.keys()、Set.prototype.values()、Set.prototype.entries()、Set.prototype.forEach()、扩展运算符（...））
  2.WeakSet（与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先，WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 不能遍历，是因为成员都是弱引用，不会引发内存泄漏）
  3.Map（类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。同set，无add()，变为get()与set()）
  4.Weakap（与Map结构类似，也是用于生成键值对的集合；区别：1.WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名；2.WeakMap的键名所指向的对象，不计入垃圾回收机制）

12.Proxy

  1.概述（Proxy 用于修改某些操作的默认行为，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写）
  2.Proxy 实例的方法
      	get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
		set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
		has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
		deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
		ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
		getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
		defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
		preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
		getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
		isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
		setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
		apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
		construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
  3.Proxy.revocable()；返回一个可取消的 Proxy 实例（Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问）
  4.this 问题（虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理）
  5.实例：Web 服务的客户端（Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。Proxy 也可以用来实现数据库的 ORM 层）
  
13.Reflect

  1.概述
      （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。
      （2） 修改某些Object方法的返回结果，让其变得更合理。
      （3） 让Object操作都变成函数行为。
      （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
  2.静态方法
      Reflect对象一共有 13 个静态方法。
		Reflect.apply(target, thisArg, args)；等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
		Reflect.construct(target, args)；等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
		Reflect.get(target, name, receiver)；查找并返回target对象的name属性，如果没有该属性，则返回undefined。
		Reflect.set(target, name, value, receiver)；设置target对象的name属性等于value。
		Reflect.defineProperty(target, name, desc)；基本等同于Object.defineProperty，用来为对象定义属性。
		Reflect.deleteProperty(target, name)；等同于delete obj[name]，用于删除对象的属性。
		Reflect.has(target, name)；对应name in obj里面的in运算符。
		Reflect.ownKeys(target)；用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
		Reflect.isExtensible(target)；对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
		Reflect.preventExtensions(target)；对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
		Reflect.getOwnPropertyDescriptor(target, name)；等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象。
		Reflect.getPrototypeOf(target)；用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
		Reflect.setPrototypeOf(target, prototype)；用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。
  3.实例：使用 Proxy 实现观察者模式（观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。）
  
14.Promise 对象

  1.Promise 的含义
      异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
      特点：
      （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
      （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。
  2.基本用法
    Promise对象是一个构造函数，用来生成Promise实例。Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
  3.Promise.prototype.then()
      then方法是定义在原型对象Promise.prototype上的，为 Promise 实例添加状态改变时的回调函数，可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。这两个函数都是可选的，不一定要提供。
  4.Promise.prototype.catch()
      Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数
  5.Promise.prototype.finally()
      finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
  6.Promise.all()
      用于将多个 Promise 实例，包装成一个新的 Promise 实例。const p = Promise.all([p1, p2, p3]);
      Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，可以使用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。
      p的状态由p1、p2、p3决定，分成两种情况。
      （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
      （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
  7.Promise.race()
      同样是将多个 Promise 实例，包装成一个新的 Promise 实例。const p = Promise.race([p1, p2, p3]);
    只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
  8.Promise.allSettled()
       接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束
  9.Promise.any()
       该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态
  10.Promise.resolve()
       将现有对象转为 Promise 对象（（1）参数是一个 Promise 实例、（2）参数是一个thenable对象、（3）参数不是具有then()方法的对象，或根本就不是对象、（4）不带有任何参数）
  11.Promise.reject()
      会返回一个新的 Promise 实例，该实例的状态为rejected
  12.应用
      1.加载图片
      2.Generator 函数与 Promise 的结合
  13. Promise.try()
      模拟try代码块。为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。
    让同步函数同步执行，异步函数异步执行（第一种写法是用async函数来写，包在立即执行的匿名函数里；第二种写法是使用new Promise()；第三种写法是Promise.try）

15.Iterator 和 for...of 循环

  1.Iterator（遍历器）的概念
    它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）;
      作用：1.为各种数据结构，提供一个统一的、简便的访问接口；2.使得数据结构的成员能够按某种次序排列；3. ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
      Iterator 的遍历过程：每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束
  2.默认 Iterator 接口
      默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。
  3.调用 Iterator 接口的场合
      （1）解构赋值（对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。）
      （2）扩展运算符
      （3）yield*
      （4）其他场合（由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口）	for...of    Array.from()   Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])   Promise.all()   Promise.race()
  4.字符串的 Iterator 接口
      字符串是一个类似数组的对象，也原生具有 Iterator 接口。
  5.Iterator 接口与 Generator 函数
  6.遍历器对象的 return()，throw()
      return()方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return()方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return()方法
       throw()方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。
  7.for...of 循环（作为遍历所有数据结构的统一的方法）
       一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。
      for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
  8.数组
      数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器
      for...in：循环读取键名
      for...of：循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。数组的遍历器接口只返回具有数字索引的属性
  9.Set 和 Map 结构
      Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环
      注意：首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。
  10.计算生成的数据结构
      entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。
      keys() 返回一个遍历器对象，用来遍历所有的键名。
      values() 返回一个遍历器对象，用来遍历所有的键值。
  11.类似数组的对象
      字符串、DOM NodeList 对象、arguments对象等
  12.对象
      对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。
      解决：1.使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。2.使用 Generator 函数将对象重新包装一下。
  13.与其他遍历语法的比较
      for循环：比较麻烦
    forEach方法：无法中途跳出forEach循环，break命令或return命令都不能奏效。
    for...in循环：可以遍历数组的键名
               缺点：1.数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。
                    2.for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。                    
		    3.某些情况下，for...in循环会以任意顺序遍历键名。
                    总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组
    for...of循环： 1.有着同for...in一样的简洁语法，但是没有for...in那些缺点。
                    2.不同于forEach方法，它可以与break、continue和return配合使用。
		    3.提供了遍历所有数据结构的统一操作接口。




















  



























      







     

